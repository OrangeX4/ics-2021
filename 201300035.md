# PA 3

## 201300035 方盛俊

## 1. 阶段一: 穿越时空的旅程

### 1.1 设置异常入口地址

要想正确实现 `csrrw` 指令, 就需要先加入 `mtvec`, `mcause`, `mstatus`, `mepc` 这四个寄存器, 然后再使用这些寄存器实现第一条 CSR 指令.

1. 加入 CSR 寄存器
   1. 在 `isa-def.h` 加入 CSR 的四个寄存器 `mtvec`, `mcause`, `mstatus`, `mepc`
   2. 在 `reg.h` 中加入 `csr(idx)` 全局宏
   3. 在 `reg.c` 中修改寄存器有关的函数, 如 `isa_reg_display()`
2. 加入 `csrrw` 指令
   1. 在 `isa-all-instr.h` 之类的添加就不过多赘述
   2. 在 `decode.c` 里加入了 `def_DopHelper(csr)` 辅助函数
      1. 用于将 12 位的 csr 地址映射到只有 4 个的 csr 寄存器中 (暂时)
      2. 这步踩了很多坑...
   3. 在 `csr.h` 加入 `def_EHelper(csrrs)` 实现对应指令

做完这些之后, 终于能开始写自陷操作了...

### 1.2 触发自陷操作

1. 完成 `ecall` 指令
   1. `rtl_j(s, isa_raise_intr(11, cpu.pc + 4)); // 异常号 11, 代表 Environment call from M-mode`
   2. 注意不要与 `mret` 重合.
2. 完成 `csrrs` 指令
3. 完成 `mret` 指令, 返回到 `mepc` 寄存器所保存的地址

这里踩了很多坑, difftest 还出问题了...

### 1.3 重新组织结构体

通过观察 `trap.S` 的内容, 对 `Context` 重新整理如下:

``` c
struct Context {
  // fix the order of these members to match trap.S
  uintptr_t gpr[32], mcause, mstatus, mepc;
  void *pdir;
};
```

### 1.4 实现正确的事件分发

1. 在 `__am_irq_handle()` 加入了 `case 11: ev.event = EVENT_YIELD; break;`, 识别异常号 `11`, 并打包为 `EVENT_YIELD` 事件.
2. 在 `do_event()` 加入了 `case EVENT_YIELD: printf("Event: Yield\n"); break;`, 识别出自陷事件 `EVENT_YIELD`, 然后输出 `Event: Yield`.


### 1.5 理解上下文结构体的前世今生 & 理解穿越时空的旅程

从 Nanos-lite 调用 `yield()` 开始, 到从 `yield()` 返回的期间, 这一趟旅程具体经历了什么?

前置工作: 初始化 `init_irq(void)`:

1. `init_irq(void)` 调用了 `cte_init(do_event)`, 将 `do_event()` 这个函数传入;
2. `cte_init()` 调用 `asm volatile("csrw mtvec, %0" : : "r"(__am_asm_trap))` 将 `__am_asm_trap()` 函数地址保存在 `mtvec` 中;
3. `cte_init()` 调用 `user_handler = handler` 将 `do_event` 保存在全局变量中, 以便后续回调;

正式工作: 调用 `yield()`:

1. `yield()` 调用了 `asm volatile("li a7, -1; ecall")`, 使用 `ecall` (设置异常号 `11`) 跳转到 `mtvec` 寄存器的 `__am_asm_trap()` 函数中;
2. `__am_asm_trap()` 使用 `addi sp, sp, -CONTEXT_SIZE` 在堆栈区初始化了 `CONTEXT_SIZE` 大小的上下文结构体 `c`, **这是上下文结构体生命周期的开端**;
3. `__am_asm_trap()` 使用 `MAP(REGS, PUSH)` 的宏展开式函数映射编程法, 类似于 `PUSH(REGS)` 这样, 将 `32` 个通用寄存器保存到了 `c` 中相应位置;
4. `__am_asm_trap()` 使用类似于 `csrr t0, mcause; STORE t0, OFFSET_CAUSE(sp)` 的汇编语句将 `mcause`, `mstatus` 和 `mepc` 三个寄存器保存到了 `c` 中相应位置;
5. `__am_asm_trap()` 将 `mstatus.MPRV` 置位, 以便通过 difftest;
6. `__am_asm_trap()` 使用 `mv a0, sp; jal __am_irq_handle` 将位于堆栈区的 `c` 上下文结构体保存到函数传参寄存器 `a0` 中, 作为函数参数调用并传给 `__am_irq_handle()` 函数;
7. `__am_irq_handle()` 通过 `c->mcause` 判别异常号, 并创建对应 `Event ev`, 调用 `user_handler(ev, c)`, 即调用上文提到的 `do_event(e, c)`;
8.  `do_event()` 对异常或中断做完相应处理后, 返回到 `__am_irq_handle()` 中;
9.  `__am_irq_handle()` 也做完了相应处理, 返回到 `__am_asm_trap()` 中;
10. `__am_asm_trap()` 使用类似于 `LOAD t1, OFFSET_STATUS(sp); csrw mstatus, t1` 的汇编语句将 `c` 中相应位置保存到 `mstatus` 和 `mepc` 两个寄存器中;
11. `__am_asm_trap()` 使用 `MAP(REGS, POP)` 将 `c` 中相应位置数据复原回 `32` 个通用寄存器中;
12. `__am_asm_trap()` 使用 `addi sp, sp, CONTEXT_SIZE` 将堆栈区复原, 相当于将 `c` 释放, **这是上下文结构体生命周期的结束**;
13. `__am_asm_trap()` 使用 `mret`, 将 `mtvec` 寄存器内保存的数据取出, 并跳转到该位置, 即回到了调用中断代码的 `yield()` 函数中;
14. `yield()` 处理完所有事情, 便返回了, 进而调用了 `panic("Should not reach here")`.

此外, 我还在 `trap.S` 的 `csrw mepc, t2` 指令前加入了 `addi t2, t2, 4`, 来实现自陷指令 `ecall` PC 加 4 的效果.

### 1.6 异常处理的踪迹 - etrace

修改 Kconfig, 并在 `intr.c` 的 `isa_raise_intr(word_t NO, vaddr_t epc)` 中加入

``` c
#ifdef CONFIG_ETRACE
log_write("[etrace] mcause: %d, mstatus: %x, mepc: %x\n", cpu.csr[1]._32, cpu.csr[2]._32, cpu.csr[3]._32);
#endif
```

即可.


## 2. 阶段二: 穿越时空的旅程

### 2.1 简化操作: 自动化脚本

我们需要在 `riscv32-nemu` 和 `native` 之间不断切换, 要做如下三件事情:

1. 使用 `ISA=xxx` 编译 dummy
2. 把编译出的 dummy ELF 文件作为 nanos-lite 的 ramdisk, 复制过去
3. 使用 `ARCH=xxx` 编译并运行 nanos-lite

为了简化操作, 写了一个脚本, 脚本如下所示:

``` bash
#!/bin/bash
program=dummy

function init() {

    make -C ../navy-apps/tests/dummy ISA=$1
    cp ../navy-apps/tests/dummy/build/dummy-$1 ./build/ramdisk.img
    make ARCH=$2 run
}

case $1 in
nemu)
    init riscv32 riscv32-nemu
    ;;
native)
    init am_native native
    ;;
*)
    echo "Invalid input..."
    exit
    ;;
esac
```

### 2.2 堆和栈在哪里?

> **Question:** 我们提到了代码和数据都在可执行文件里面, 但却没有提到堆 (heap) 和栈 (stack). 为什么堆和栈的内容没有放入可执行文件里面? 那程序运行时刻用到的堆和栈又是怎么来的? AM 的代码是否能给你带来一些启发?
>
> **Answer:** 堆和栈是进程才有的概念, 程序只是一个静态的可执行文件, 包含着一个进程运行所需的代码信息, 本身并不是运行着的. 只有程序被加载为进程, 才会出现堆和栈.


### 2.3 如何识别不同格式的可执行文件?

> **Question:** 如果你在GNU/Linux下执行一个从Windows拷过来的可执行文件, 将会报告"格式错误". 思考一下, GNU/Linux是如何知道"格式错误"的?
> 
> **Answer:** 通过文件头的 "魔数", 对于 ELF 文件来说, 这个魔数为 `Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00`.


### 2.4  冗余的属性?

> **Question:** 使用 readelf 查看一个 ELF 文件的信息, 你会看到一个 segment 包含两个大小的属性, 分别是 FileSiz 和 MemSiz, 这是为什么? 再仔细观察一下, 你会发现 FileSiz 通常不会大于相应的 MemSiz, 这又是为什么?
> 
> **Answer:** 因为程序中 `.bss` 节对应的是未初始化的全局变量, 在程序中也就不需要占用空间, 即长度为 0; 但是对于进程来说, `.bss` 节加载到内存中, 仍然是需要占用空间的, 此时长度就不为 0, 因此 `MemSiz` 总长度也会大于 `FileSiz`.


### 2.5 实现 loader

我实现的 `loader` 如下:

``` c
static uintptr_t loader(PCB *pcb, const char *filename) {

    Elf_Ehdr elf = {};
    ramdisk_read(&elf, 0, sizeof(Elf_Ehdr));

    // Make sure that the file is an elf file
    assert(*(uint32_t *)elf.e_ident == ELF_MAGIC);

    Elf_Phdr ph = {};
    for (int i = 0; i < elf.e_phnum; ++i) {
        ramdisk_read(&ph, elf.e_phoff + i * sizeof(Elf_Phdr), sizeof(Elf_Phdr));
        if (ph.p_type == PT_LOAD) {
            // Copy to [VirtAddr, VirtAddr + FileSiz)
            memcpy((void *)ph.p_vaddr, &ramdisk_start + ph.p_offset, ph.p_filesz);
            // Set [VirtAddr + FileSiz, VirtAddr + MenSiz) with zero
            memset((void *)(ph.p_vaddr + ph.p_filesz), 0, ph.p_memsz - ph.p_filesz);
        }
    }
    
    return elf.e_entry;
}
```

此外, 我还修改了 `cte.c` 中 `event` 分发的方式, 这里我们认为 `a7 == -1` 时是 `EVENT_YIELD`, 否则是 `EVENT_SYSCALL`

``` c
 switch (c->mcause) {
   case 11: {
     if (c->GPR1 == -1) {
       ev.event = EVENT_YIELD;
     } else {
       ev.event = EVENT_SYSCALL;
     }
     break;
   }
   default: ev.event = EVENT_ERROR; break;
 }
```


### 2.6 识别系统调用

目前 dummy 已经通过 `_syscall_()` 直接触发系统调用, 我需要让 Nanos-lite 识别出系统调用事件 EVENT_SYSCALL.

于是我在 `irq.c` 中将其修改为

``` c
switch (e.event) {
 case EVENT_YIELD: printf("EVENT_YIELD, GPR1: %d\n", c->GPR1); break;
 case EVENT_SYSCALL: {
     do_syscall(c);
     break;
 }
 default: panic("Unhandled event ID = %d, GPR1: %d\n", e.event, c->GPR1);
}
```


### 2.7 实现 SYS_yield 系统调用

我在补充完整 `syscall.h` 的基础上, 在 `syscall.c` 中加入了:

``` c
void do_syscall(Context *c) {
  uintptr_t a[4];
  a[0] = c->GPR1;
  a[1] = c->GPR2;
  a[2] = c->GPR3;
  a[3] = c->GPRx;

  switch (a[0]) {
    case SYS_yield: {
        yield();
        c->GPRx = 0;
        break;
    }
    default: panic("Unhandled syscall ID = %d", a[0]);
  }
}
```

并且 `riscv32-nemu.h` 要改为:

``` c
#define GPR1 gpr[17] // a7
#define GPR2 gpr[10] // a0
#define GPR3 gpr[11] // a1
#define GPR4 gpr[12] // a2
#define GPRx gpr[10] // a0
```


### 2.8 实现 SYS_exit 系统调用

在 `syscall.c` 中加入

``` c
case SYS_exit: halt(0); break;
```

即可.


### 2.9 系统调用的痕迹 - strace

``` c
#ifdef ENABLE_STRACE
 printf("[strace] %s(%d, %d, %d) = %d\n", syscall_names[a[0]], a[1], a[2], a[3], c->GPRx);
#endif

 switch (a[0]) {
     case SYS_exit:
         printf("[strace] SYS_exit(%d)\n", a[1]);
         halt(0);
         break;
 }
```

其中开关位于 `common.h`.

具体输出大致如下:

```
[strace] SYS_yield(0, 0, 0) = 0
EVENT_YIELD, GPR1: -1
[strace] SYS_exit(0, 0, 0) = 0
[strace] SYS_exit(0)
```


### 2.10 标准输出

``` c
case SYS_write: {
   // int _write(int fd, void *buf, size_t count)
   if (a[1] == 1 || a[1] == 2) {
       for (size_t i = 0; i < a[3]; ++i) putch(((char *) a[2])[i]);
       c->GPRx = a[3];
   }
   break;
}
```


### 2.11 堆区管理

在 Navy 的 `syscall.c` 中加入

``` c
extern char end;
void *program_break = &end;

void *_sbrk(intptr_t increment) {
  if (increment == 0) {
      return program_break;
  }
  if (_syscall_(SYS_brk, increment, 0, 0)) {
    return -1;
  } else {
    program_break += increment;
    return program_break - increment;
  }
}
```


### 2.12 hello 程序是什么, 它从而何来, 要到哪里去

> 我们知道 `navy-apps/tests/hello/hello.c` 只是一个 C 源文件, 它会被编译链接成一个ELF文件. 那么, hello程序一开始在哪里? 它是怎么出现内存中的? 为什么会出现在目前的内存位置? 它的第一条指令在哪里? 究竟是怎么执行到它的第一条指令的? hello 程序在不断地打印字符串, 每一个字符又是经历了什么才会最终出现在终端上?

1. 在 `navy-apps/tests/hello` 目录下经过 `make ISA=riscv32` 编译之后, 在 `build` 目录下生成了 `hello-riscv32` 文件, 这是一个 ELF 格式的可执行文件.
2. 我们将 `hello-riscv32` 文件复制到 `nanos-lite/build/ramdisk.img` 文件, 作为给 Nanos 使用的 "内存虚拟盘" `ramdisk` 加载. 
3. Nanos 的 `resources.S` 内部通过 `ramdisk_start:; .incbin "build/ramdisk.img"; ramdisk_end:` 语法将 `ramdisk.img` 文件加载进内存里.
4. Nanos 在 `ramdisk.c` 文件中使用 `&ramdisk_start` 来获取已经加载进内存的 `ramdisk.img` 对应的内存地址.
5. `hello-riscv32` 即 `ramdisk` 被我们自己编写的 `loader()` 函数识别为一个 ELF 文件, 并按照约定加载到地址 `0x83000000` 中.
6. 第一条指令的地址通过 ELF 文件中 `elf.e_entry` 给出.
7. 为了调用它的第一条指令, 我们只需要将 `elf.e_entry` 作为一个函数地址进行调用即可, 就像 `((void (*)())entry)()` 这样调用.
8. hello 程序打印字符串的经历如下:
   1. `hello.c` 调用 `printf("Hello World from Navy-apps for the %dth time!\n", i ++);`
   2. libc 库中的 `printf()` 会将字符暂时放置到 `wbuf.c` 的缓冲区中, 当达到一定条件一会调用一次 `_write()` 函数进行输出.
   3. `_write()` 函数会触发中断 `_syscall_(SYS_write, fd, buf, count)`, 后者调用了 `ecall` 指令.
   4. `ecall` 指令实际上跳转到了 `__am_asm_trap()` 函数, 封装好 `Context c` 后进一步调用 `__am_irq_handle(c)` 函数, 其封装为事件 `EVENT_SYSCALL` 后调用 `do_event(Event e, Context* c)`
   5. `do_event(Event e, Context* c)` 确认是事件 `EVENT_SYSCALL` 后, 调用 `do_syscall(Context *c)`, 其中 `c->GPR1` 存储了系统调用号, `c->GPR2~4` 是三个参数, `c->GPRx` 用来存放返回值.
   6. 对于 `SYS_write` 系统调用, 我们通过 `for (size_t i = 0; i < a[3]; ++i) putch(((char *) a[2])[i]);` 输出每一个字符.
   7. AM 的 `putch()` 又调用了 NEMU 里的串口设备, 进行输出.
   8. 最后由 NEMU 把字符输出到控制台.




## 3. 阶段三: 简易文件系统

### 3.1 简易文件系统

我在 `device.c` 文件中加入

``` c
size_t serial_write(const void *buf, size_t offset, size_t len) {
  for (size_t i = 0; i < len; ++i) putch(((char *) buf)[i]);
  return len;
}
```

并完成了 `fs.c` 里的大部分 API 实现

``` c
/* This is the information about all files in disk. */
static Finfo file_table[] __attribute__((used)) = {
  [FD_STDIN]  = {"stdin", 0, 0, invalid_read, invalid_write},
  [FD_STDOUT] = {"stdout", 0, 0, invalid_read, serial_write},
  [FD_STDERR] = {"stderr", 0, 0, invalid_read, serial_write},
#include "files.h"
};

void init_fs() {
  // TODO: initialize the size of /dev/fb
}

char *fs_getname(int fd) {
    assert(fd < LENGTH(file_table));
    return file_table[fd].name;
}

int fs_open(const char *pathname, int flags, int mode) {
    int fd = 0;
    for (; fd < LENGTH(file_table) && strcmp(pathname, file_table[fd].name); ++fd);
    assert(fd != LENGTH(file_table));
    file_table[fd].open_offset = 0;
    return fd;
}


size_t fs_read(int fd, void *buf, size_t len) {
    assert(buf != 0);
    assert(fd < LENGTH(file_table));
    Finfo *finfo = &file_table[fd];
    if (finfo->read) {
        // Virtual File
        finfo->read(buf, 0, len);
        // finfo->open_offset += len;
    } else {
        // Normal File
        assert(finfo->open_offset <= finfo->size);
        ramdisk_read(buf, finfo->disk_offset + finfo->open_offset, len);
        finfo->open_offset += len;
    }
    return len;
}


size_t fs_write(int fd, const void *buf, size_t len) {
    assert(buf != 0);
    assert(fd < LENGTH(file_table));
    Finfo *finfo = &file_table[fd];
    if (finfo->write) {
        // Virtual File
        finfo->write(buf, 0, len);
        // finfo->open_offset += len;
    } else {
        // Normal File
        assert(finfo->open_offset <= finfo->size);
        ramdisk_write(buf, finfo->disk_offset + finfo->open_offset, len);
        finfo->open_offset += len;
    }
    return len;
}


size_t fs_lseek(int fd, size_t offset, int whence) {
    assert(fd < LENGTH(file_table));
    switch (whence) {
    case SEEK_SET:
        // assert(offset <= file_table[fd].size);
        file_table[fd].open_offset = offset;
        break;
    case SEEK_CUR:
        // assert(file_table[fd].open_offset + offset <= file_table[fd].size);
        file_table[fd].open_offset += offset;
        break;
    case SEEK_END:
        // assert(file_table[fd].size + offset <= file_table[fd].size);
        file_table[fd].open_offset = file_table[fd].size + offset;
        break;
    
    default:
        panic("Invalid whence");
        break;
    }
    return file_table[fd].open_offset;
}


int fs_close(int fd) {
    // Always success
    return 0;
}
```

### 3.2 让 loader 使用文件

具体实现如下:

``` c
static uintptr_t loader(PCB *pcb, const char *filename) {

    Elf_Ehdr elf = {};
    int fd = fs_open(filename, 0, 0);
    // assert(fd == 4); // bin/hello
    // ramdisk_read(&elf, 0, sizeof(Elf_Ehdr));
    fs_read(fd, &elf, sizeof(Elf_Ehdr));

    // Make sure that the file is an elf file
    assert(*(uint32_t *)elf.e_ident == ELF_MAGIC);

    Elf_Phdr ph = {};
    for (int i = 0; i < elf.e_phnum; ++i) {
        // ramdisk_read(&ph, elf.e_phoff + i * sizeof(Elf_Phdr), sizeof(Elf_Phdr));
        fs_lseek(fd, elf.e_phoff + i * sizeof(Elf_Phdr), SEEK_SET);
        fs_read(fd, &ph, sizeof(Elf_Phdr));
        if (ph.p_type == PT_LOAD) {
            // Copy to [VirtAddr, VirtAddr + FileSiz)
            // memcpy((void *)ph.p_vaddr, &ramdisk_start + ph.p_offset, ph.p_filesz);
            fs_lseek(fd, ph.p_offset, SEEK_SET);
            fs_read(fd, (void *)ph.p_vaddr, ph.p_filesz);
            // Set [VirtAddr + FileSiz, VirtAddr + MenSiz) with zero
            memset((void *)(ph.p_vaddr + ph.p_filesz), 0, ph.p_memsz - ph.p_filesz);
        }
    }
    
    return elf.e_entry;
}

void naive_uload(PCB *pcb, const char *filename) {
    uintptr_t entry = loader(pcb, filename);
    Log("Jump to entry = %p", entry);
    ((void (*)())entry)();
}
```

此时便可以在 `proc.c` 里任意切换程序了:

``` c
void init_proc() {
  switch_boot_pcb();

  Log("Initializing processes...");

  // load program here

//   naive_uload(NULL, "/bin/dummy");
//   naive_uload(NULL, "/bin/hello");
  naive_uload(NULL, "/bin/file-test");
}
```

### 3.3 实现完整的文件系统

要让测试程序 `navy-apps/tests/file-test` 正常运行, 我们需要实现 `syscall.c` 对应的接口, 这部分不过多赘述.

为了编译它, 需要把它加到 `navy-apps/Makefile` 的 `TESTS` 变量中, 这样它最终就会被包含在 ramdisk 镜像中. 


### 3.4 支持 sfs 的 strace

为了实现这个功能, 我在 `fs.c` 里加入了 `char *fs_getname(int fd)` 函数, 如下:  

``` c
char *fs_getname(int fd) {
    assert(fd < LENGTH(file_table));
    return file_table[fd].name;
}
```

然后在 `syscall.c` 中完善对应的 strace, 如

``` c
case SYS_read: {
   // int _read(int fd, void *buf, size_t count)
   c->GPRx = fs_read(a[1], (void *)a[2], a[3]);
#ifdef ENABLE_STRACE
   printf("[strace] %s(\"%s\", *buf = %p, len = %d) = %d\n",
          syscall_names[a[0]], fs_getname(a[1]), a[2], a[3], c->GPRx);
#endif
   break;
}
```

具体输出格式大致如下:

```
[strace] SYS_brk(increment = 448) = 0
[strace] SYS_brk(increment = 316) = 0
[strace] SYS_open(*path = "/share/files/num", flags = 2, mode = 438) = 22
[strace] SYS_brk(increment = 4096) = 0
[strace] SYS_lseek("/share/files/num", offset = 0, whence = SEEK_END) = 5000
[strace] SYS_lseek("/share/files/num", offset = 2500, whence = SEEK_SET) = 2500
[strace] SYS_read("/share/files/num", *buf = 0x83009ec0, len = 1024) = 1024
[strace] SYS_read("/share/files/num", *buf = 0x83009ec0, len = 1024) = 1024
[strace] SYS_read("/share/files/num", *buf = 0x83009ec0, len = 1024) = 1024
[strace] SYS_lseek("/share/files/num", offset = 4999, whence = SEEK_SET) = 49
```


### 3.5 把串口抽象成文件

为了让让 VFS 支持串口的写入. 我们的代码已经改为了

``` c
static Finfo file_table[] __attribute__((used)) = {
  [FD_STDIN]  = {"stdin", 0, 0, invalid_read, invalid_write},
  [FD_STDOUT] = {"stdout", 0, 0, invalid_read, serial_write},
  [FD_STDERR] = {"stderr", 0, 0, invalid_read, serial_write},
#include "files.h"
};
```


### 3.6 实现 gettimeofday

> 实现 `gettimeofday` 系统调用, 这一系统调用的参数含义请 RTFM. 实现后, 在 `navy-apps/tests/` 中新增一个 `timer-test` 测试, 在测试中通过 `gettimeofday()` 获取当前时间, 并每过 0.5 秒输出一句话.

首先我们在 `device.c` 里通过 `io_read(AM_TIMER_UPTIME).us` 读取当前的微秒数, 并写入 `timeval tv` 结构体里, 实现 `int gettimeofday(struct timeval *tv, struct timezone *tz)` 的功能

``` c
int gettimeofday(struct timeval *tv, struct timezone *tz) {
    assert(tv);
    tv->tv_usec = io_read(AM_TIMER_UPTIME).us;
    tv->tv_sec = tv->tv_usec / 1000000;
    if (tz) {
        tz->tz_minuteswest = tv->tv_sec / 60;
        tz->tz_dsttime = 0;
    }
    return 0;
}
```

并在 `syscall.c` 里加入对应的接口和 strace:

``` c
case SYS_gettimeofday: {
   // int _gettimeofday(struct timeval *tv, struct timezone *tz)
   c->GPRx = gettimeofday((struct timeval *)a[1], (struct timezone *)a[2]);
#ifdef ENABLE_STRACE
   if (a[2]) {
       printf(
           "[strace] %s(timeval = {%d, %d}, timezone = {%d, %d}) = %d\n",
           syscall_names[a[0]], ((struct timeval *)a[1])->tv_sec,
           ((struct timeval *)a[1])->tv_usec,
           ((struct timezone *)a[2])->tz_dsttime,
           ((struct timezone *)a[2])->tz_minuteswest, c->GPRx);
   } else {
       printf(
           "[strace] %s(timeval = {%d, %d}, timezone = NULL) = %d\n",
           syscall_names[a[0]], ((struct timeval *)a[1])->tv_sec,
           ((struct timeval *)a[1])->tv_usec, c->GPRx);
   }
#endif
   break;
}
```

最后完成 `timer-test.c` 并在 Makefile 中加入即可:

``` c
#include <stdio.h>
#include <assert.h>
#include <sys/_timeval.h>

#define true 1

int _gettimeofday(struct timeval *tv, struct timezone *tz);

int main() {
  struct timeval tv = {};
  _gettimeofday(&tv, NULL);
  long lst_usec = tv.tv_usec;
  long cur_usec = tv.tv_usec;
  while (true) {
    _gettimeofday(&tv, NULL);
    cur_usec = tv.tv_usec;
    if (cur_usec - lst_usec >= 500000) {
        printf("Hello, world!\n");
        lst_usec = cur_usec;
    }
  }
  return 0;
}
```

大致输出如下:

```
[strace] SYS_gettimeofday(timeval = {1, 1360942}, timezone = NULL) = 0
[strace] SYS_gettimeofday(timeval = {1, 1383621}, timezone = NULL) = 0
[strace] SYS_gettimeofday(timeval = {1, 1409805}, timezone = NULL) = 0
[strace] SYS_gettimeofday(timeval = {1, 1454106}, timezone = NULL) = 0
[strace] SYS_gettimeofday(timeval = {1, 1494646}, timezone = NULL) = 0
[strace] SYS_gettimeofday(timeval = {1, 1536292}, timezone = NULL) = 0
[strace] SYS_gettimeofday(timeval = {1, 1585010}, timezone = NULL) = 0
[strace] SYS_gettimeofday(timeval = {1, 1636254}, timezone = NULL) = 0
[strace] SYS_gettimeofday(timeval = {1, 1691342}, timezone = NULL) = 0
[strace] SYS_gettimeofday(timeval = {1, 1747402}, timezone = NULL) = 0
[strace] SYS_gettimeofday(timeval = {1, 1809710}, timezone = NULL) = 0
[strace] SYS_gettimeofday(timeval = {1, 1882482}, timezone = NULL) = 0
[strace] SYS_brk(increment = 1048) = 0
[strace] SYS_brk(increment = 3176) = 0
Hello, world!
```


### 3.7 实现 NDL 的时钟

在 `NDL.c` 中加入

```c
uint32_t NDL_GetTicks() {
  struct timeval tv = {};
  _gettimeofday(&tv, NULL);
  return tv.tv_usec / 1000;
}
```

在 `timer-test.c` 中改为

```c
int main() {
  long lst_msec = NDL_GetTicks();
  long cur_msec = lst_msec;
  while (true) {
    cur_msec = NDL_GetTicks();
    if (cur_msec - lst_msec >= 500) {
        printf("Hello, world!\n");
        lst_msec = cur_msec;
    }
  }
  return 0;
}
```


### 3.8 把按键输入抽象成文件

`device.c` 修改为

```c
size_t events_read(void *buf, size_t offset, size_t len) {
  AM_INPUT_KEYBRD_T ev = io_read(AM_INPUT_KEYBRD);
  if (ev.keycode == AM_KEY_NONE) return 0;
  return snprintf(buf, len, "%s %s\n", ev.keydown ? "kd" : "ku", keyname[ev.keycode]);
}
```

`fs.c` 修改为

```c
static Finfo file_table[] __attribute__((used)) = {
  [FD_STDIN]  = {"stdin", 0, 0, invalid_read, invalid_write},
  [FD_STDOUT] = {"stdout", 0, 0, invalid_read, serial_write},
  [FD_STDERR] = {"stderr", 0, 0, invalid_read, serial_write},
  [FD_FB] = {"fb", 0, 0, invalid_read, invalid_write},
  [FD_EVENT] = {"/dev/events", 0, 0, events_read, invalid_write},
#include "files.h"
};
```

顺便修复了 `printf` 和 `snprintf` 的 bug.

最后正确显示如下:

```
receive event: kd D

receive event: ku D

receive event: kd D

receive event: ku D

receive event: kd S

receive event: ku S

receive event: kd D

receive event: ku D
```


### 3.9 用 fopen() 还是 open()?

答案是使用 `open()`. 普通文件用 `fopen()`, 其有缓冲区以及一些其他的概念. 设备文件用 `open()`, 更接近系统调用.


### 3.10 在 NDL 中获取屏幕大小

在 `device.c` 中加入

``` c
size_t dispinfo_read(void *buf, size_t offset, size_t len) {
  AM_GPU_CONFIG_T config = io_read(AM_GPU_CONFIG);
  return snprintf(buf, len, "WIDTH:%d\nHEIGHT:%d", config.width, config.height);
}
```

在 `fs.c` 中加入

``` c
[FD_DISPINFO] = {"/proc/dispinfo", 0, 0, dispinfo_read, invalid_write},
```

在 `NDL.c` 中加入

```
// Return the next string after '\n' or NULL after '\0' 
char *parse_kv(const char *str, char *key, char *value) {
  for (; *str == ' '; ++str);
  for (; *str != ' ' && *str != ':'; ++str, ++key) *key = *str; 
  *key = '\0';
  for (; *str == ' '; ++str);
  assert(*str == ':');
  ++str;
  for (; *str == ' '; ++str);
  for (; *str != ' ' && *str != '\n' && *str != '\0'; ++str, ++value) *value = *str; 
  *value = '\0';
  for (; *str == ' '; ++str);
  assert(*str == '\n' || *str == '\0');
  if (*str == '\n') {
    ++str;
    if (*str != '\0') {
      return str;
    } else {
      return NULL;
    }
  } else if (*str == '\0') {
    return NULL;
  }
}

void NDL_OpenCanvas(int *w, int *h) {
  if (getenv("NWM_APP")) {
    // ...
  } else {
    FILE *fp_info = open("/proc/dispinfo", "r+");
    char buf[64];
    char *_buf = buf;
    read(fp_info, buf, sizeof(buf));
    close(fp_info);
    // WIDTH : 640
    // HEIGHT:480
    char key[16], value[16];
    // printf("buf:\n%s\n", buf);
    _buf = parse_kv(_buf, key, value);
    assert(_buf);
    // printf("_buf:\n%s\n", _buf);
    // printf("key: [%s]\n", key);
    // printf("value: [%s]\n", value);
    if (strcmp(key, "WIDTH") == 0) {
      screen_w = atoi(value);
      parse_kv(_buf, key, value);
    // printf("key: [%s]\n", key);
    // printf("value: [%s]\n", value);
    // assert(_buf == NULL);
      if (strcmp(key, "HEIGHT") == 0) {
        screen_h = atoi(value);
      } else {
        assert(0);
      }
    } else if (strcmp(key, "HEIGHT") == 0) {
      screen_h = atoi(value);
      parse_kv(_buf, key, value);
    //   assert(_buf == NULL);
      if (strcmp(key, "WIDTH") == 0) {
        screen_w = atoi(value);
      } else {
        assert(0);
      }
    } else {
      assert(0);
    }
    assert(screen_w);
    assert(screen_h);
    // printf("screen_w: %d\n", screen_w);
    // printf("screen_h: %d\n", screen_h);
    // printf("w: %d\n", *w);
    // printf("h: %d\n", *h);
    assert(*w <= screen_w);
    assert(*h <= screen_h);
    if (*w == 0 || *h == 0) {
      canvas_w = screen_w;
      canvas_h = screen_h;
    } else {
      canvas_w = *w;
      canvas_h = *h;
    }
  }
}
```

### 3.11 把 VGA 显存抽象成文件

首先要在 `init_fs()` 加入

``` c
file_table[FD_FB].size = get_fb_size();
```

其中 `get_fb_size()` 为

``` c
size_t get_fb_size() {
  AM_GPU_CONFIG_T config = io_read(AM_GPU_CONFIG);
  screen_w = config.width;
  screen_h = config.height;
  return screen_w * screen_h;
}
```

其次是实现 `fb_write()`:

``` c
size_t fb_write(const void *buf, size_t offset, size_t len) {
  assert(offset + len <= screen_w * screen_h);
  int x = offset % screen_w;
  int y = offset / screen_w;
  assert(x + len <= screen_w);
  io_write(AM_GPU_FBDRAW, x, y, (void *) buf, len, 1, false);
  return len;
}
```

最后是 `NDL_DrawRect()`:

```c
void NDL_DrawRect(uint32_t *pixels, int x, int y, int w, int h) {
  assert(w);
  assert(h);
  FILE *fp = open("/dev/fb", "w+");
  long off_h = (screen_h - canvas_h) / 2;
  long off_w = (screen_w - canvas_w) / 2;
  // printf("screen_h: %d\n", screen_h);
  // printf("screen_w: %d\n", screen_w);
  // printf("canvas_h: %d\n", canvas_h);
  // printf("canvas_w: %d\n", canvas_w);
  // printf("off_h: %d\n", off_h);
  // printf("off_w: %d\n", off_w);
  // printf("x: %d\n", x);
  // printf("y: %d\n", y);
  // printf("w: %d\n", w);
  // printf("h: %d\n", h);
  for (int i = 0; i < h; ++i) {
    long offset = (off_h + y + i) * screen_w + off_w + x;
    // printf("offset: %d\n", offset);
    // printf("size: %d\n", screen_h * screen_w);
    // printf("fp: %d\n", fp);
    lseek(fp, offset, SEEK_SET);
    write(fp, pixels + w * i, w);
  }
  close(fp);
}
```


### 3.12 实现更多的 fixedptc API

具体实现如下:

```c
/* Multiplies a fixedpt number with an integer, returns the result. */
static inline fixedpt fixedpt_muli(fixedpt A, int B) {
	return A * B / 256;
}

/* Divides a fixedpt number with an integer, returns the result. */
static inline fixedpt fixedpt_divi(fixedpt A, int B) {
	return A / B * 256;
}

/* Multiplies two fixedpt numbers, returns the result. */
static inline fixedpt fixedpt_mul(fixedpt A, fixedpt B) {
	return A * B / 256;
}


/* Divides two fixedpt numbers, returns the result. */
static inline fixedpt fixedpt_div(fixedpt A, fixedpt B) {
	return A / B * 256;
}

static inline fixedpt fixedpt_abs(fixedpt A) {
	return A >= 0 ? A : -A;
}

static inline fixedpt fixedpt_floor(fixedpt A) {
  return (A >> 8) << 8;
}

static inline fixedpt fixedpt_ceil(fixedpt A) {
  return ((A >> 8) << 8) + 1;
}
```


### 3.13 运行 NSlider

在 `video.c` 中加入

```c
void SDL_UpdateRect(SDL_Surface *s, int x, int y, int w, int h) {
  // printf("x: %d\n", x);
  // printf("y: %d\n", y);
  // printf("w: %d\n", w);
  // printf("h: %d\n", h);
  if (w == 0 && h == 0) {
    NDL_DrawRect(s->pixels, x, y, s->w, s->h);
  } else {
    NDL_DrawRect(s->pixels, x, y, w, h);
  }
}
```

然后在 `event.c` 中加入

```c
int SDL_WaitEvent(SDL_Event *event) {
  char buf[16];
  int len;
  while (true) {
    len = NDL_PollEvent(buf, 16);
    clean_line_break(buf);
    if (len) {
      // printf("Event: %s\n", buf);
      // printf("Ku Result: %d\n", strncmp(buf, "ku ", 3));
      // printf("Kd Result: %d\n", strncmp(buf, "kd ", 3));
      if (strncmp(buf, "ku ", 3) == 0) {
        // printf("SDL_KEYUP\n");
        event->type = SDL_KEYUP;
        int key = 0;
        for (; key < LENGTH(keyname) && strcmp(buf + 3, keyname[key]) != 0; ++key); 
        assert(key < LENGTH(keyname));
        event->key.keysym.sym = key;
      } else if (strncmp(buf, "kd ", 3) == 0) {
        // printf("SDL_KEYDOWN\n");
        event->type = SDL_KEYDOWN;
        int key = 0;
        for (; key < LENGTH(keyname) && strcmp(buf + 3, keyname[key]) != 0; ++key); 
        assert(key < LENGTH(keyname));
        event->key.keysym.sym = key;
      } else {
        assert(0);
      }
      break;
    }
  }
  return 1;
}
```


### 3.14 MENU (开机菜单)

```c
void SDL_BlitSurface(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect) {
  assert(dst && src);
  assert(dst->format->BitsPerPixel == src->format->BitsPerPixel);
  int x, y, w, h;
  if (srcrect) {
    x = srcrect->x;
    y = srcrect->y;
    w = srcrect->w;
    h = srcrect->h;
  } else {
    x = 0;
    y = 0;
    w = src->w;
    h = src->h;
  }
  assert(dstrect);
  for (int i = 0; i < h; ++i) {
    for (int j = 0; j < w; ++j) {
      ((uint32_t *) dst->pixels)[(dstrect->y + i) * dst->w + (dstrect->x + j)] =
        ((uint32_t *) src->pixels)[(y + i) * src->w + (x + j)]; 
    }
  }
}

void SDL_FillRect(SDL_Surface *dst, SDL_Rect *dstrect, uint32_t color) {
  int x, y, w, h;
  if (dstrect) {
    x = dstrect->x;
    y = dstrect->y;
    w = dstrect->w;
    h = dstrect->h;
  } else {
    x = 0;
    y = 0;
    w = dst->w;
    h = dst->h;
  }
  for (int i = 0; i < h; ++i) {
    for (int j = 0; j < w; ++j) {
      ((uint32_t *)dst->pixels)[(y + i) * dst->w + (x + j)] = color; 
    }
  }
}
```


### 3.15 NTerm

代码如下:

```c
int SDL_PollEvent(SDL_Event *ev) {
  char buf[16];
  int len;
  len = NDL_PollEvent(buf, 16);
  clean_line_break(buf);
  if (len) {
    parse_event_buf(buf, ev);
    return 1;
  } else {
    return 0;
  }
}
```


### 3.16 Flappy Bird

我们要先安装 SDL1, 而不是 SDL2 系统库, 具体安装如下:

``` bash
sudo apt-get install libsdl1.2-dev
sudo apt-get install libsdl-image1.2-dev
sudo apt-get install libsdl-mixer1.2-dev
sudo apt-get install libsdl-ttf2.0-dev
sudo apt-get install libsdl-gfx1.2-dev
```

`IMG_Load()` 函数实现如下:

```c
SDL_Surface* IMG_Load(const char *filename) {
  int fp = fopen(filename, "r");
  assert(fp);
  fseek(fp, 0, SEEK_END);
  int size = ftell(fp);
  printf("Size : [%d]\n", size);
  unsigned char *buf = malloc(size);
  fseek(fp, 0, SEEK_SET);
  fread(buf, size, 1, fp);
  SDL_Surface *s = STBIMG_LoadFromMemory(buf, size);
  fclose(fp);
  return s;
}
```


### 3.17 PAL (仙剑奇侠传)

修改过后的 `video.c` 文件如下:

```c
static uint32_t convert_RGBA_ARGB(SDL_Color color) {
  return (((uint32_t) color.r) << 16) + (((uint32_t) color.g) << 8) + (uint32_t) color.b;
}

void SDL_BlitSurface(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect) {
  assert(dst && src);
  assert(dst->format->BitsPerPixel == src->format->BitsPerPixel);
  int x, y, w, h, dst_x, dst_y;
  if (srcrect) {
    x = srcrect->x;
    y = srcrect->y;
    w = srcrect->w;
    h = srcrect->h;
  } else {
    x = 0;
    y = 0;
    w = src->w;
    h = src->h;
  }
  if (dstrect) {
    dst_x = dstrect->x;
    dst_y = dstrect->y;
  } else {
    dst_x = 0;
    dst_y = 0;
  }
  for (int i = 0; i < h; ++i) {
    for (int j = 0; j < w; ++j) {
      if (src->format->palette) {
        dst->pixels[(dst_y + i) * dst->w + (dst_x + j)] =
          src->pixels[(y + i) * src->w + (x + j)]; 
      } else {
        ((uint32_t *) dst->pixels)[(dst_y + i) * dst->w + (dst_x + j)] =
          ((uint32_t *) src->pixels)[(y + i) * src->w + (x + j)]; 
      }
    }
  }
}

void SDL_FillRect(SDL_Surface *dst, SDL_Rect *dstrect, uint32_t color) {
  int x, y, w, h;
  // uint8_t color_8bit;
  if (dstrect) {
    x = dstrect->x;
    y = dstrect->y;
    w = dstrect->w;
    h = dstrect->h;
  } else {
    x = 0;
    y = 0;
    w = dst->w;
    h = dst->h;
  }
  // printf("FillRect\n");
  // if (dst->format->palette) {
  //   uint8_t i = 0, ncolors = dst->format->palette->ncolors;
  //   for (; i < ncolors && convert_RGBA_ARGB(dst->format->palette->colors[i]) != color; i++);
  //   if (i >= ncolors) {
  //     printf("Invalid color: [0x%x]\n", color);
  //     color_8bit = 0;
  //   } else {
  //     color_8bit = i;
  //   }
  //   // assert(i < ncolors);
  // }
  for (int i = 0; i < h; ++i) {
    for (int j = 0; j < w; ++j) {
      if (dst->format->palette) {
        dst->pixels[(y + i) * dst->w + (x + j)] = (uint8_t) color;
      } else {
        ((uint32_t *)dst->pixels)[(y + i) * dst->w + (x + j)] = color; 
      }
    }
  }
}

uint32_t pixels_buf[300 * 400 * 10];

void SDL_UpdateRect(SDL_Surface *s, int x, int y, int w, int h) {
  // printf("x: %d\n", x);
  // printf("y: %d\n", y);
  // printf("w: %d\n", w);
  // printf("h: %d\n", h);
  if (s->format->palette) {
    for (int i = 0; i < s->h; ++i) {
      for (int j = 0; j < s->w; ++j) {
        pixels_buf[i * (s->w) + j] =
          convert_RGBA_ARGB(s->format->palette->colors[s->pixels[i * (s->w) + j]]);
      }
    }
    if (w == 0 && h == 0) {
      NDL_DrawRect(pixels_buf, x, y, s->w, s->h);
    } else {
      NDL_DrawRect(pixels_buf, x, y, w, h);
    }
  } else {
    if (w == 0 && h == 0) {
      NDL_DrawRect((uint32_t *) s->pixels, x, y, s->w, s->h);
    } else {
      NDL_DrawRect((uint32_t *) s->pixels, x, y, w, h);
    }
  }
}
```

还有 `event.c` 文件如下:

```c
int SDL_PollEvent(SDL_Event *ev) {
  char buf[16];
  int len = NDL_PollEvent(buf, 16);
  if (len) {
    clean_line_break(buf);
    parse_event_buf(buf, ev);
    if (ev->type == SDL_KEYDOWN) {
      keys_status[ev->key.keysym.sym] = true;
    } else if (ev->type == SDL_KEYUP) {
      keys_status[ev->key.keysym.sym] = false;
    }
    return 1;
  } else {
    return 0;
  }
}

int SDL_WaitEvent(SDL_Event *event) {
  while (!SDL_PollEvent(event));
  return true;
}

int SDL_PeepEvents(SDL_Event *ev, int numevents, int action, uint32_t mask) {
  assert(0);
  return 0;
}

uint8_t* SDL_GetKeyState(int *numkeys) {
  assert(numkeys == NULL);
  return keys_status;
}
```

还有点 bugs 没修好, 但是也没什么办法了...


### 3.18 展示你的批处理系统

修改 `syscall.c` 为

```c
case SYS_exit: {
#ifdef ENABLE_STRACE
  printf("[strace] %s(%d)\n", syscall_names[a[0]], a[1]);
#endif
  // halt(0);
  naive_uload(NULL, ENTRY_PROGRAM);
  break;
}
case SYS_execve: {
#ifdef ENABLE_STRACE
  printf("[strace] %s(file = %s)\n", syscall_names[a[0]], (char *) a[1]);
#endif
  if (*((char *) a[1]) == '/') {
    naive_uload(NULL, (char *) a[1]);
  } else {
    int len = strlen((char *) a[3]);
    strcpy(program_buf, (char *) a[3]);
    *(program_buf + len) = '/';
    strcpy(program_buf + len + 1, (char *) a[1]);
    // printf("Program buf: [%s]\n", program_buf);
    naive_uload(NULL, program_buf);
  }
  break;
}
```

然后在 `builtin-sh.cpp` 中写入

```cpp
static void clean_line_break(char *buf) {
  for (; *buf != '\n' && *buf != '\0'; ++buf);
  if (*buf == '\n') *buf = '\0';
}

static bool isStringAllSpaces(const char *buf) {
  bool result = true;
  for (; *buf != '\n' && *buf != '\0'; ++buf) {
    if (*buf != ' ') result = false;
  }
  return result;
}

static void sh_handle_cmd(const char *cmd) {
  char *buf = (char *) malloc(strlen(cmd) + 1);
  strcpy(buf, cmd);
  clean_line_break(buf);
  if (!isStringAllSpaces(buf)) {
    execve(buf, NULL, (char *const *) getenv("PATH"));
  }
}
```

### 3.19 理解上下文结构体的前世今生 & 理解穿越时空的旅程

从 Nanos-lite 调用 `yield()` 开始, 到从 `yield()` 返回的期间, 这一趟旅程具体经历了什么?

前置工作: 初始化 `init_irq(void)`:

1. `init_irq(void)` 调用了 `cte_init(do_event)`, 将 `do_event()` 这个函数传入;
2. `cte_init()` 调用 `asm volatile("csrw mtvec, %0" : : "r"(__am_asm_trap))` 将 `__am_asm_trap()` 函数地址保存在 `mtvec` 中;
3. `cte_init()` 调用 `user_handler = handler` 将 `do_event` 保存在全局变量中, 以便后续回调;

正式工作: 调用 `yield()`:

1. `yield()` 调用了 `asm volatile("li a7, -1; ecall")`, 使用 `ecall` (设置异常号 `11`) 跳转到 `mtvec` 寄存器的 `__am_asm_trap()` 函数中;
2. `__am_asm_trap()` 使用 `addi sp, sp, -CONTEXT_SIZE` 在堆栈区初始化了 `CONTEXT_SIZE` 大小的上下文结构体 `c`, **这是上下文结构体生命周期的开端**;
3. `__am_asm_trap()` 使用 `MAP(REGS, PUSH)` 的宏展开式函数映射编程法, 类似于 `PUSH(REGS)` 这样, 将 `32` 个通用寄存器保存到了 `c` 中相应位置;
4. `__am_asm_trap()` 使用类似于 `csrr t0, mcause; STORE t0, OFFSET_CAUSE(sp)` 的汇编语句将 `mcause`, `mstatus` 和 `mepc` 三个寄存器保存到了 `c` 中相应位置;
5. `__am_asm_trap()` 将 `mstatus.MPRV` 置位, 以便通过 difftest;
6. `__am_asm_trap()` 使用 `mv a0, sp; jal __am_irq_handle` 将位于堆栈区的 `c` 上下文结构体保存到函数传参寄存器 `a0` 中, 作为函数参数调用并传给 `__am_irq_handle()` 函数;
7. `__am_irq_handle()` 通过 `c->mcause` 判别异常号, 并创建对应 `Event ev`, 调用 `user_handler(ev, c)`, 即调用上文提到的 `do_event(e, c)`;
8.  `do_event()` 对异常或中断做完相应处理后, 返回到 `__am_irq_handle()` 中;
9.  `__am_irq_handle()` 也做完了相应处理, 返回到 `__am_asm_trap()` 中;
10. `__am_asm_trap()` 使用类似于 `LOAD t1, OFFSET_STATUS(sp); csrw mstatus, t1` 的汇编语句将 `c` 中相应位置保存到 `mstatus` 和 `mepc` 两个寄存器中;
11. `__am_asm_trap()` 使用 `MAP(REGS, POP)` 将 `c` 中相应位置数据复原回 `32` 个通用寄存器中;
12. `__am_asm_trap()` 使用 `addi sp, sp, CONTEXT_SIZE` 将堆栈区复原, 相当于将 `c` 释放, **这是上下文结构体生命周期的结束**;
13. `__am_asm_trap()` 使用 `mret`, 将 `mtvec` 寄存器内保存的数据取出, 并跳转到该位置, 即回到了调用中断代码的 `yield()` 函数中;
14. `yield()` 处理完所有事情, 便返回了, 进而调用了 `panic("Should not reach here")`.

此外, 我还在 `trap.S` 的 `csrw mepc, t2` 指令前加入了 `addi t2, t2, 4`, 来实现自陷指令 `ecall` PC 加 4 的效果.


### 3.20 hello 程序是什么, 它从而何来, 要到哪里去

> 我们知道 `navy-apps/tests/hello/hello.c` 只是一个 C 源文件, 它会被编译链接成一个ELF文件. 那么, hello程序一开始在哪里? 它是怎么出现内存中的? 为什么会出现在目前的内存位置? 它的第一条指令在哪里? 究竟是怎么执行到它的第一条指令的? hello 程序在不断地打印字符串, 每一个字符又是经历了什么才会最终出现在终端上?

1. 在 `navy-apps/tests/hello` 目录下经过 `make ISA=riscv32` 编译之后, 在 `build` 目录下生成了 `hello-riscv32` 文件, 这是一个 ELF 格式的可执行文件.
2. 我们将 `hello-riscv32` 文件复制到 `nanos-lite/build/ramdisk.img` 文件, 作为给 Nanos 使用的 "内存虚拟盘" `ramdisk` 加载. 
3. Nanos 的 `resources.S` 内部通过 `ramdisk_start:; .incbin "build/ramdisk.img"; ramdisk_end:` 语法将 `ramdisk.img` 文件加载进内存里.
4. Nanos 在 `ramdisk.c` 文件中使用 `&ramdisk_start` 来获取已经加载进内存的 `ramdisk.img` 对应的内存地址.
5. `hello-riscv32` 即 `ramdisk` 被我们自己编写的 `loader()` 函数识别为一个 ELF 文件, 并按照约定加载到地址 `0x83000000` 中.
6. 第一条指令的地址通过 ELF 文件中 `elf.e_entry` 给出.
7. 为了调用它的第一条指令, 我们只需要将 `elf.e_entry` 作为一个函数地址进行调用即可, 就像 `((void (*)())entry)()` 这样调用.
8. hello 程序打印字符串的经历如下:
   1. `hello.c` 调用 `printf("Hello World from Navy-apps for the %dth time!\n", i ++);`
   2. libc 库中的 `printf()` 会将字符暂时放置到 `wbuf.c` 的缓冲区中, 当达到一定条件一会调用一次 `_write()` 函数进行输出.
   3. `_write()` 函数会触发中断 `_syscall_(SYS_write, fd, buf, count)`, 后者调用了 `ecall` 指令.
   4. `ecall` 指令实际上跳转到了 `__am_asm_trap()` 函数, 封装好 `Context c` 后进一步调用 `__am_irq_handle(c)` 函数, 其封装为事件 `EVENT_SYSCALL` 后调用 `do_event(Event e, Context* c)`
   5. `do_event(Event e, Context* c)` 确认是事件 `EVENT_SYSCALL` 后, 调用 `do_syscall(Context *c)`, 其中 `c->GPR1` 存储了系统调用号, `c->GPR2~4` 是三个参数, `c->GPRx` 用来存放返回值.
   6. 对于 `SYS_write` 系统调用, 我们通过 `for (size_t i = 0; i < a[3]; ++i) putch(((char *) a[2])[i]);` 输出每一个字符.
   7. AM 的 `putch()` 又调用了 NEMU 里的串口设备, 进行输出.
   8. 最后由 NEMU 把字符输出到控制台.


### 3.21 仙剑奇侠传究竟如何运行

1. 第一步是先渲染背景.

```c
//
// Read the bitmaps
//
PAL_MKFReadChunk(buf, 320 * 200, BITMAPNUM_SPLASH_UP, gpGlobals->f.fpFBP);
Decompress(buf, buf2, 320 * 200);
PAL_FBPBlitToSurface(buf2, lpBitmapUp);
PAL_MKFReadChunk(buf, 320 * 200, BITMAPNUM_SPLASH_DOWN, gpGlobals->f.fpFBP);
Decompress(buf, buf2, 320 * 200);
PAL_FBPBlitToSurface(buf2, lpBitmapDown);
PAL_MKFReadChunk(buf, 32000, SPRITENUM_SPLASH_TITLE, gpGlobals->f.fpMGO);
Decompress(buf, buf2, 32000);
lpBitmapTitle = (LPBITMAPRLE)PAL_SpriteGetFrame(buf2, 0);
PAL_MKFReadChunk(buf, 32000, SPRITENUM_SPLASH_CRANE, gpGlobals->f.fpMGO);
Decompress(buf, lpSpriteCrane, 32000);
```

其中 `PAL_MKFReadChunk()` 中调用 `fseek()` 和 `fread()` 读取了 MKF 文件内容, 然后保存在 `buf` 里. 而 `fread()` 最后会在 Nanos 里调用 `memcpy(buf, &ramdisk_start + offset, len);` 从内存中读取对应的 MKF 文件.

通过这种方式初始化了好了结构体, 分布是 `lpBitmapUp`, `lpBitmapDown` 和标题 `lpBitmapTitle`.

1. 进入渲染的主循环.

2. 通过 `PAL_ProcessEvent();` 读取按键信息, 以便随时跳出.

3. 画仙鹤的主要部分.

```c
//
// Draw the cranes...
//
for (i = 0; i < 9; i++)
{
   LPCBITMAPRLE lpFrame = PAL_SpriteGetFrame(lpSpriteCrane,
      cranepos[i][2] = (cranepos[i][2] + (iCraneFrame & 1)) % 8);
   cranepos[i][1] += ((iImgPos > 1) && (iImgPos & 1)) ? 1 : 0;
   PAL_RLEBlitToSurface(lpFrame, gpScreen,
      PAL_XY(cranepos[i][0], cranepos[i][1]));
   cranepos[i][0]--;
}
iCraneFrame++;
```

通过 `PAL_SpriteGetFrame()` 获取仙鹤的像素, 然后通过 `PAL_RLEBlitToSurface()` 写入屏幕 `gpScreen` 中.

4. 画标题的主要部分.

```c
//
// Draw the title...
//
if (PAL_RLEGetHeight(lpBitmapTitle) < iTitleHeight)
{
   //
   // HACKHACK
   //
   WORD w = lpBitmapTitle[2] | (lpBitmapTitle[3] << 8);
   w++;
   lpBitmapTitle[2] = (w & 0xFF);
   lpBitmapTitle[3] = (w >> 8);
}

PAL_RLEBlitToSurface(lpBitmapTitle, gpScreen, PAL_XY(255, 10));
```

5. 通过 `VIDEO_UpdateScreen(NULL)` 更新屏幕.

6. 进而调用 `SDL_UpdateRect()` 更新屏幕.

7. 进而调用 `NDL_DrawRect()` 更新屏幕.

8. 进而通过 `lseek(fp_fb, offset, SEEK_SET)` 和 `write(fp_fb, pixels + w * i, 4 * w)` 的方式写入 `/dev/fb` 设备中, 相当于一个系统调用.

9. Nanos 的 `size_t fb_write(const void *buf, size_t offset, size_t len)` 被调用.

10. AM 的 `io_write(AM_GPU_FBDRAW, x, y, (void *) buf, len / 4, 1, false);` 被调用.

11. AM 的 `__am_gpu_fbdraw(AM_GPU_FBDRAW_T *ctl)` 被调用, 然后写入 NEMU 对应的屏幕内存.

12. NEMU 的 `static inline void update_screen()` 函数被调用, 然后具体实现为

```c
static inline void update_screen() {
  SDL_UpdateTexture(texture, NULL, vmem, SCREEN_W * sizeof(uint32_t));
  SDL_RenderClear(renderer);
  SDL_RenderCopy(renderer, texture, NULL, NULL);
  SDL_RenderPresent(renderer);
}
```